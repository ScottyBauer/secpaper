\documentclass{sig-alternate-05-2015}
\begin{document}

\setcopyright{acmcopyright}
\title{Mitigating signal handler exploits in Linux
\titlenote{(Produces the permission block, and
copyright information). For use with
SIG-ALTERNATE.CLS. Supported by ACM.}}
\numberofauthors{2}
\author{
\alignauthor
Abhiram Balasubramanian\\
       \affaddr{University of Utah}\\
       \email{abhiram@cs.utah.edu}
% 2nd. author
\alignauthor
Scott Bauer\\
       \affaddr{University of Utah}\\
       \email{sbauer@eng.utah.edu}
}

\maketitle
\begin{abstract}
As exploitation mitigations advance attackers look for new methods to control the flow of a program after exploiting a vulnerability. Recent exploit mitigations such as StackCookies [CITE ME], Data Execution Prevention (W^X) [CITE ME] and Address Space Layout Ranomization (ASLR) [CITE ME], have forced exploit authors to use techniques that jump around the text segment of an ELF in memory to achieve code execution. The newest form of exploitation, Sigreturn Oriented Programming (SROP), uses signal frames, and the kernel to achieve code execution by tricking the kernel to change the instruction pointer to some arbitrary location in the code.\\
Signals are one of the commonly used kernel to user/user to user asynchronous notification mechanisms in UNIX. By registering a signal handler, a process can handle these asynchronous events outside its control flow. As signal frames are stored on the process stack, attackers can create exploits by setting up dummy signal frames on the stack and initiate returns from signals that the kernel never delivered. This method bypasses all current exploit mitigation techniques and  appears more convenient as kernel never keeps track of the signals it delivered.\\
We develop a mechanism on top of the 4.1 Linux kernel to systematically stop SROP exploitaion.

\end{abstract}
\section{Introduction}
Over the past 25 years Operating System designers and compiler designers have been facing off against exploit developers. The OS and Compiler designers  come up with a novel technique to suppress some form of exploitation method, for example Stack cookies, ASLR, DEP, etc. The exploit developers however continuously find methods around these exploit mitigations and the cat-and-mouse game continues.  A paper titled “Framing Signals -- A return to portable Shellcode”,  presents a new novel exploitation technique based off the idea of Return Oriented Programming (ROP). In a ROP an attacker locates gadgets in the assembly and continuously returns to those locations to build working shellcode. In this new technique attackers leverage the way Unix-like operating systems deliver signals to applications to create portable and reliable shellcode. This technique works by crafting a signal frame on the stack and tricking the kernel into thinking it is a legitimate signal frame. This causes the kernel to tell the process to start executing where the attacker wants leading to arbitrary code execution.\\
\indent
To mitigate this new style of exploitation we design, implement and use a SROP mitigation technique based off of the idea of cookies originally developed to stop stack based buffer overflows. We test our implementation against two different SROP exploits, both of which are stopped by the new mitigation technique.

\section {Background}
<TBD>
\subsection{Signal Handling in Linux}
<TBD>
\subsection{Signal Return Oriented Programming}
<TBD>


\section {System Implementation}
We classify the system implementation in two sections - construction
of the exploit and the kernel implementation to mitigate the exploitation.

\subsection{A simple SROP exploit}
We implemented an exploit by carefully constructing a stack frame to give
control to a shellcode. The key idea in creating this exploit is to make
the instruction pointer (IP) point to the code that we want to execute. 
Unlike return oriented programming, SROP needs to know the location of 
code that executes a sigreturn system call. To accomplish this, we simply
created a gadget function that respects the system ABI to execute a system
call. Essentially, the gadget sets the system register RAX with the syscall
number (0x15 for sigreturn) and calls syscall instruction to execute sigreturn.
See Figure~\ref{fig:SFEC} for more details.

\subsubsection{Finding gadgets}
\par The ideal way of constructing an attack is to find an address of a
syscall instruction in the system address map. Although the vsyscall area provides 
an address of a syscall instruction, on 64 bit kernels the area is emulated. 
The kernel has a mechanism to check if the syscall number was the one which the 
vsycall area supports to execute, if not, the kernel throws a SIGSEV error 
saying an exploit has been attempted.  
\par So, in order to get the exploit working, we placed a gadget with a syscall 
instruction and have the code point to this gadget instead of the vsyscall area.
Although there are other methods to find the syscall address, such as finding a 
syscall address in libc shared library, this method is more elegant and simple to 
construct the attack.

\subsubsection{Preparing arbitrary code execution}
In order to execute the shellcode, we first need to ensure that sigreturn system
call executes successfuly so that it restores the shellcode context later on. We
place a fake ucontext frame on stack such that it executes a execve instruction to
load shell. For this purpose, it is important to set the code segment register to 
point to 0x33 so that it runs in 64 bit mode, RAX set to syscall number of execve
system call, RDI and RSI points to the arguments (shell in our case) respectively.
When the executable is loaded, it overwrites the return address with the sigreturn
system call address and loads the fake ucontext frame to launch the shell.

\section{Related Work}
For this work, \cite{bosman2014framing} is most relevant and a one 
stop reference. The paper provides detailed technical information 
on signal handling on UNIX based systems and introduces SROP as a 
generic exploitation technique. It also points to hints on abusing 
sigreturn system call, backdoor techniques based on SROP and ways to 
mitigate SROP attacks. 

\par In our current work, we have implemented a simple execve based 
exploit technique and a stack cookie based kernel level implementation
to address the exploitation as suggested in the paper. The paper authors
have also submitted a kernel patch targeting a different approach - counter
per process in the kernel space that keeps track of number of signal handlers
currently executing, the counter increases on signal delivery and decreases
on sigreturn path. Although this technique prevents SROP technique, it has
its own drawbacks in terms of counter roll-over and creates complications with
multi-threaded applications. We presume that these are some valid reasons why
the patch has not made it into the mainline kernel. In contrast, our approach 
is more elegant and leaves less to no room for the attacker to guess the cookie
value. Moreover, techniques suggested in the paper target older kernel versions, 
we have tested the exploit and the kernel fix on the latest kernel version (4.3).

\par As SROP is a type of an ROP attack, we find \cite{cowan1998stackguard}
related as this work implements a compiler feature which adds a cookie to the stack, 
as well as support to verify the cookie upon return of a function.  Buffer overflow 
attacks are probably the most famous form of attack gaining notoriety in the early 90's
The method works by modifying gcc such that it generates code that places a
32 bit identifier on the stack before the return address during a call instruction.
Also prior to a return gcc has the function call a verify method which validates 
that the 32 bit identifier is the same identifier that was placed there previously.
This research is very similar to the approach we have taken to prevent SROP.  
We utilize a stack cookie generated by the kernel to prevent an attacker from 
creating an arbitrary signal frame on the stack causing the kernel to jump arbitrarily 
through the code.

\par Another relevant reference is \cite{li2010defeating} as the work implements a 
compiler technique to prevent ret instructions from being generated in a kernel image. 
By removing ret instructions from the kernel it prevents an entire class of attack, 
Return Oriented Programming (ROP) from ever occurring because the fundamental feature 
of the attack is removed. The authors modify LLVM such that it will never generate a ret 
op-code, as well as will never generate a sequence of instructions that contain a ret op-code, 
if you were to jump between instructions. Instead of developing a technique to systematically 
remove the necessary elements for the attack we have used a hardening technique to 
prevent the attack.

\bibliographystyle{abbrv}
\bibliography{sigproc}
\end{document}
